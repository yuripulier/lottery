# -*- coding: utf-8 -*-
"""Lottery.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I0dfshv7Zqrj6Ye9eCd5VqhuTeSuEdEV
"""

import tensorflow as tf
import pandas as pd
import numpy as np
from operator import itemgetter

class Lottery:

  def __init__ (self, results):
    self.results = pd.DataFrame(results.dropna(axis=0, how='all'), dtype=np.dtype("int32"))

  def __repr__(self):
      return '<{}: {}>\n'.format(self.__class__.__name__, self.results)

  #----------------------------------------------#
  def __partitions(self, V, p, r):
    pivotvalue = V[p]
    left = p + 1
    right = r
    done = False
    while not done:
      while left <= right and V[left] <= pivotvalue:
        left = left + 1
      while V[right] >= pivotvalue and right >= left:
        right = right - 1
      if right < left:
        done = True
      else:
        temp = V[left]
        V[left] = V[right]
        V[right] = temp
    temp = V[p]
    V[p] = V[right]
    V[right] = temp
    return right

  #----------------------------------------------#
  def __quicksort(self, V, p, r):
    if (p<r):
      q = self.__partitions(V,p,r)
      self.__quicksort(V,p,q-1)
      self.__quicksort(V,q+1,r)

  #----------------------------------------------#
  def sort(self):
    R = self.results.to_numpy()
    for i in range(len(R)):
      self.__quicksort(R[i,1:], 0, len(R[i,1:])-1)
    self.results = pd.DataFrame(R, columns = self.results.columns)

  #----------------------------------------------#
  def __is_prime(self, num):
    if (num==2 or num==3 or num==5 or num==7 or num==11 or num==13 or num==17 or num==19 or num==23):
      return True
    else:
      return False

  #----------------------------------------------#
  def __is_mult_3(self, num):
    if (num % 3 == 0):
      return True
    else:
      return False

  #----------------------------------------------#
  def __is_fibo(self, num):
    next = 0
    previous = 0
    while (next <= num):
      next = next + previous
      previous = next - previous
      if (next == 0):
        next = next + 1
      if (num == next):
        return True
    return False

  #----------------------------------------------#
  def __binary_search(self, A, left, right, item):
    # 1. Caso base: o elemento não está presente. 
    if right < left:
        return 0
    middle = (left + right) // 2
    # 2. Nosso palpite estava certo: o elemento está no meio do arranjo. 
    if A[middle] == item:
        return 1
    # 3. O palpite estava errado: atualizamos os limites e continuamos a busca. 
    elif A[middle] > item:
        return self.__binary_search(A, left, middle - 1, item)
    else: # A[meio] < item
        return self.__binary_search(A, middle + 1, right, item)

  #----------------------------------------------#
  def more_drawn(self):
    S = np.array(self.results)
    # criando o vetor zerado para a quantidade de bolas
    qnt_balls = []
    for i in range(1,26):
      qnt_balls.append([i, 0])
    # contando as quantidades de cada bola
    for i in range(len(S)):  # todas as linhas
      for j in range(1,16):     # todas as colunas
        qnt_balls[S[i][j]-1][1] = qnt_balls[S[i][j]-1][1] + 1
    # ordenando o array pela quantidade de bolas
    qnt_balls = sorted(qnt_balls, key=itemgetter(1))

    return pd.DataFrame(qnt_balls, columns = ['Balls', 'Occurrence'])

  #----------------------------------------------#
  def even_odd(self):
    # criando o vetor zerado para obter quantidade de bolas pares e impares em cada sorteio
    ev_od = []
    S = np.array(self.results)
    for i in range(len(S)):
      ev_od.append([0, 0]) # [quantidade par , quantidade impar]

    # preenchendo o vetor com as ocorrencias de pares e impares
    for i in range(len(S)):
      for j in range(1,16):
        if (S[i][j] % 2 == 0):  # par
          ev_od[i][0] = ev_od[i][0] + 1
        else:   # impar
          ev_od[i][1] = ev_od[i][1] + 1
    
    # precisamos agora calcular a quantidade de ocorrencias para cada par de [par, impar]
    qnt_ocur = []    # quantidade de ocorrencias
    for i in range(16):
      qnt_ocur.append([[15-i, i], 0]) # [quantidade par , quantidade impar, quantidade de ocorrencias]

    for i in range(len(ev_od)):
      for j in range(16):
        if (ev_od[i] == [15-j, j]):
          qnt_ocur[j][1] = qnt_ocur[j][1] + 1

    # ordenando o array pela quantidade de ocorrencias
    qnt_ocur = sorted(qnt_ocur, key=itemgetter(1), reverse= True)
    df_ocur_even_odd = pd.DataFrame(qnt_ocur, columns=['Even, Odd', 'Occurrence'])
    return df_ocur_even_odd

  #----------------------------------------------#
  def prime_number(self):
    # Novo DataFrame para armazenar as informações dos números primos em todos os sorteios
    qnt_prime = pd.DataFrame(columns=['Contest', 'Quantity Primes'])
    tot = 0
    # Inserindo no DataFrame as quantidades de numeros primos por sorteio
    for i in range(len(self.results)):
      for j in range(1,16):
        if (self.__is_prime(self.results.iloc[i][j])):
          tot = tot + 1
      qnt_prime = qnt_prime.append({'Contest': i+1,  'Quantity Primes': tot}, ignore_index=True)
      tot = 0
    # DataFrame com a quantidade de ocorrencia em relação a quantidade de números primos nos sorteios já realizados
    df_ocur_primes = pd.DataFrame({'Quantity Primes': [1,2,3,4,5,6,7,8,9], 
                                    'Occurrence': [0,0,0,0,0,0,0,0,0],
                                    'Percentage Occurrences': [0,0,0,0,0,0,0,0,0]}, dtype=np.dtype("int32"))
    # Preenchendo o numero de ocorrencias 
    for i in range(len(qnt_prime)):
      if (qnt_prime.iloc[i][1] == 1):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 1, other=df_ocur_primes.iloc[0][1] + 1)
      elif (qnt_prime.iloc[i][1] == 2):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 2, other=df_ocur_primes.iloc[1][1] + 1)
      elif (qnt_prime.iloc[i][1] == 3):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 3, other=df_ocur_primes.iloc[2][1] + 1)
      elif (qnt_prime.iloc[i][1] == 4):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 4, other=df_ocur_primes.iloc[3][1] + 1)
      elif (qnt_prime.iloc[i][1] == 5):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 5, other=df_ocur_primes.iloc[4][1] + 1)
      elif (qnt_prime.iloc[i][1] == 6):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 6, other=df_ocur_primes.iloc[5][1] + 1)
      elif (qnt_prime.iloc[i][1] == 7):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 7, other=df_ocur_primes.iloc[6][1] + 1)
      elif (qnt_prime.iloc[i][1] == 8):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 8, other=df_ocur_primes.iloc[7][1] + 1)
      elif (qnt_prime.iloc[i][1] == 9):
        df_ocur_primes['Occurrence'] = df_ocur_primes['Occurrence'].where(cond=df_ocur_primes['Quantity Primes'] != 9, other=df_ocur_primes.iloc[8][1] + 1)
    # Soma as ocorrencias
    tot = 0
    for i in range(len(df_ocur_primes)):
      tot = tot + df_ocur_primes.iloc[i][1]
    # Preenchendo a percentagem do numero de ocorrencias
    for i in range(len(df_ocur_primes)):
      df_ocur_primes['Percentage Occurrences'] = df_ocur_primes['Percentage Occurrences'].where(cond=df_ocur_primes['Quantity Primes'] != i+1, other=(df_ocur_primes.iloc[i][1] * 100) / tot)  
    return df_ocur_primes

  #----------------------------------------------#
  def mult_of_three(self):
    # Novo DataFrame para armazenar as informações dos números multiplos de 3 em todos os sorteios
    qnt_mult = pd.DataFrame(columns=['Contest', 'Multiples of 3'])
    tot = 0
    # Inserindo no DataFrame as quantidades de numeros multiplos de 3 por sorteio
    for i in range(len(self.results)):
      for j in range(1,16):
        if (self.__is_mult_3(self.results.iloc[i][j])):
          tot = tot + 1
      qnt_mult = qnt_mult.append({'Contest': i+1,  'Multiples of 3': tot}, ignore_index=True)
      tot = 0
    # DataFrame com a quantidade de ocorrencia em relação a quantidade de números multiplos de 3 nos sorteios já realizados
    df_ocur_mult = pd.DataFrame({'Multiples of 3': [1,2,3,4,5,6,7,8],
                                    'Occurrence': [0,0,0,0,0,0,0,0],
                                    'Percentage Occurrences': [0,0,0,0,0,0,0,0]}, dtype=np.dtype("int32"))
    # Preenchendo o numero de ocorrencias
    for i in range(len(qnt_mult)):
      if (qnt_mult.iloc[i][1] == 1):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 1, other=df_ocur_mult.iloc[0][1] + 1)
      elif (qnt_mult.iloc[i][1] == 2):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 2, other=df_ocur_mult.iloc[1][1] + 1)
      elif (qnt_mult.iloc[i][1] == 3):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 3, other=df_ocur_mult.iloc[2][1] + 1)
      elif (qnt_mult.iloc[i][1] == 4):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 4, other=df_ocur_mult.iloc[3][1] + 1)
      elif (qnt_mult.iloc[i][1] == 5):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 5, other=df_ocur_mult.iloc[4][1] + 1)
      elif (qnt_mult.iloc[i][1] == 6):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 6, other=df_ocur_mult.iloc[5][1] + 1)
      elif (qnt_mult.iloc[i][1] == 7):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 7, other=df_ocur_mult.iloc[6][1] + 1)
      elif (qnt_mult.iloc[i][1] == 8):
        df_ocur_mult['Occurrence'] = df_ocur_mult['Occurrence'].where(cond=df_ocur_mult['Multiples of 3'] != 8, other=df_ocur_mult.iloc[7][1] + 1)
    # Soma as ocorrencias
    tot = 0
    for i in range(len(df_ocur_mult)):
      tot = tot + df_ocur_mult.iloc[i][1]
    # Preenchendo a percentagem do numero de ocorrencias
    for i in range(len(df_ocur_mult)):
      df_ocur_mult['Percentage Occurrences'] = df_ocur_mult['Percentage Occurrences'].where(cond=df_ocur_mult['Multiples of 3'] != i+1, other=(df_ocur_mult.iloc[i][1] * 100) / tot)  
    return df_ocur_mult
  #----------------------------------------------#

  def fibonacci(self):
    # Novo DataFrame para armazenar as informações dos números de fibonacci em todos os sorteios
    qnt_fibo = pd.DataFrame(columns=['Contest', 'Fibonacci Number'])
    tot = 0
    # Inserindo no DataFrame as quantidades dos números de fibonacci em todos os sorteios
    for i in range(len(self.results)):
      for j in range(1,16):
        if (self.__is_fibo(self.results.iloc[i][j])):
          tot = tot + 1
      qnt_fibo = qnt_fibo.append({'Contest': i+1,  'Fibonacci Number': tot}, ignore_index=True)
      tot = 0
    # DataFrame com a quantidade de ocorrencia em relação a quantidade de números multiplos de 3 nos sorteios já realizados
    df_ocur_fibo = pd.DataFrame({'Fibonacci Number': [1,2,3,4,5,6,7], 
                                    'Occurrence': [0,0,0,0,0,0,0],
                                    'Percentage Occurrences': [0,0,0,0,0,0,0]}, dtype=np.dtype("int32"))
    # Preenchendo o numero de ocorrencias
    for i in range(len(qnt_fibo)):
      if (qnt_fibo.iloc[i][1] == 1):
        df_ocur_fibo['Occurrence'] = df_ocur_fibo['Occurrence'].where(cond=df_ocur_fibo['Fibonacci Number'] != 1, other=df_ocur_fibo.iloc[0][1] + 1)
      elif (qnt_fibo.iloc[i][1] == 2):
        df_ocur_fibo['Occurrence'] = df_ocur_fibo['Occurrence'].where(cond=df_ocur_fibo['Fibonacci Number'] != 2, other=df_ocur_fibo.iloc[1][1] + 1)
      elif (qnt_fibo.iloc[i][1] == 3):
        df_ocur_fibo['Occurrence'] = df_ocur_fibo['Occurrence'].where(cond=df_ocur_fibo['Fibonacci Number'] != 3, other=df_ocur_fibo.iloc[2][1] + 1)
      elif (qnt_fibo.iloc[i][1] == 4):
        df_ocur_fibo['Occurrence'] = df_ocur_fibo['Occurrence'].where(cond=df_ocur_fibo['Fibonacci Number'] != 4, other=df_ocur_fibo.iloc[3][1] + 1)
      elif (qnt_fibo.iloc[i][1] == 5):
        df_ocur_fibo['Occurrence'] = df_ocur_fibo['Occurrence'].where(cond=df_ocur_fibo['Fibonacci Number'] != 5, other=df_ocur_fibo.iloc[4][1] + 1)
      elif (qnt_fibo.iloc[i][1] == 6):
        df_ocur_fibo['Occurrence'] = df_ocur_fibo['Occurrence'].where(cond=df_ocur_fibo['Fibonacci Number'] != 6, other=df_ocur_fibo.iloc[5][1] + 1)
      elif (qnt_fibo.iloc[i][1] == 7):
        df_ocur_fibo['Occurrence'] = df_ocur_fibo['Occurrence'].where(cond=df_ocur_fibo['Fibonacci Number'] != 7, other=df_ocur_fibo.iloc[6][1] + 1)
    # Soma as ocorrencias
    tot = 0
    for i in range(len(df_ocur_fibo)):
      tot = tot + df_ocur_fibo.iloc[i][1]
    # Preenchendo a percentagem do numero de ocorrencias
    for i in range(len(df_ocur_fibo)):
      df_ocur_fibo['Percentage Occurrences'] = df_ocur_fibo['Percentage Occurrences'].where(cond=df_ocur_fibo['Fibonacci Number'] != i+1, other=(df_ocur_fibo.iloc[i][1] * 100) / tot)
    return df_ocur_fibo

  #----------------------------------------------#
  def repeated_dozens(self):
    self.sort()
    # Novo DataFrame para armazenar as informações dos números repetidos em relação ao sorteio anterior
    qnt_rept = pd.DataFrame(columns=['Contest', 'Repeated Dozens'])
    tot = 0
    # Inserindo no DataFrame as quantidades dos números repetidos em relação ao sorteio anterior
    for i in range(1, len(self.results)):
      for j in range(1,16):
        tot = tot + self.__binary_search(self.results.iloc[i,1:], 0, len(self.results.iloc[i,1:])-1, self.results.iloc[i-1,j])
      qnt_rept = qnt_rept.append({'Contest': i+1,  'Repeated Dozens': tot}, ignore_index=True)
      tot = 0
    # DataFrame com a quantidade de ocorrencia em relação a quantidade de números multiplos de 3 nos sorteios já realizados
    df_ocur_rept = pd.DataFrame({'Repeated Dozens': [5,6,7,8,9,10,11,12,13,14,15], 
                                    'Occurrence': [0,0,0,0,0,0,0,0,0,0,0],
                                    'Percentage Occurrences': [0,0,0,0,0,0,0,0,0,0,0]}, dtype=np.dtype("int32"))
    # Preenchendo o numero de ocorrencias
    for i in range(len(qnt_rept)):
      if (qnt_rept.iloc[i][1] == 5):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 5, other=df_ocur_rept.iloc[0][1] + 1)
      elif (qnt_rept.iloc[i][1] == 6):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 6, other=df_ocur_rept.iloc[1][1] + 1)
      elif (qnt_rept.iloc[i][1] == 7):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 7, other=df_ocur_rept.iloc[2][1] + 1)
      elif (qnt_rept.iloc[i][1] == 8):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 8, other=df_ocur_rept.iloc[3][1] + 1)
      elif (qnt_rept.iloc[i][1] == 9):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 9, other=df_ocur_rept.iloc[4][1] + 1)
      elif (qnt_rept.iloc[i][1] == 10):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 10, other=df_ocur_rept.iloc[5][1] + 1)
      elif (qnt_rept.iloc[i][1] == 11):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 11, other=df_ocur_rept.iloc[6][1] + 1)
      elif (qnt_rept.iloc[i][1] == 12):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 12, other=df_ocur_rept.iloc[7][1] + 1)
      elif (qnt_rept.iloc[i][1] == 13):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 13, other=df_ocur_rept.iloc[8][1] + 1)
      elif (qnt_rept.iloc[i][1] == 14):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 14, other=df_ocur_rept.iloc[9][1] + 1)
      elif (qnt_rept.iloc[i][1] == 15):
        df_ocur_rept['Occurrence'] = df_ocur_rept['Occurrence'].where(cond=df_ocur_rept['Repeated Dozens'] != 15, other=df_ocur_rept.iloc[10][1] + 1)
    # Soma as ocorrencias
    tot = 0
    for i in range(len(df_ocur_rept)):
      tot = tot + df_ocur_rept.iloc[i][1]
    # Preenchendo a percentagem do numero de ocorrencias
    for i in range(len(df_ocur_rept)):
      df_ocur_rept['Percentage Occurrences'] = df_ocur_rept['Percentage Occurrences'].where(cond=df_ocur_rept['Repeated Dozens'] != i+5, other=(df_ocur_rept.iloc[i][1] * 100) / tot)
  
    return df_ocur_rept
